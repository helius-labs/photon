//! `SeaORM` Entity. Generated by sea-orm-codegen 0.10.6

use sea_orm::entity::prelude::*;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(table_name = "accounts")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub hash: Vec<u8>,
    pub data: Option<Vec<u8>>,
    pub data_hash: Option<Vec<u8>>,
    pub address: Option<Vec<u8>>,
    pub owner: Vec<u8>,
    pub tree: Vec<u8>,
    /// Queue pubkey, for batched trees output queue pubkey
    pub queue: Vec<u8>,
    pub leaf_index: i64,
    pub in_output_queue: bool,
    pub nullifier_queue_index: Option<i64>,
    pub nullified_in_tree: bool,
    pub tree_type: i32,
    pub nullifier: Option<Vec<u8>>,
    pub tx_hash: Option<Vec<u8>>,
    pub seq: Option<i64>,
    pub slot_created: i64,
    pub spent: bool,
    pub prev_spent: Option<bool>,
    #[sea_orm(column_type = "Decimal(Some((20, 0)))")]
    pub lamports: Decimal,
    #[sea_orm(column_type = "Decimal(Some((20, 0)))", nullable)]
    pub discriminator: Option<Decimal>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::token_accounts::Entity")]
    TokenAccounts,
}

impl Related<super::token_accounts::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::TokenAccounts.def()
    }
}

impl Related<super::transactions::Entity> for Entity {
    fn to() -> RelationDef {
        super::account_transactions::Relation::Transactions.def()
    }
    fn via() -> Option<RelationDef> {
        Some(super::account_transactions::Relation::Accounts.def().rev())
    }
}

impl ActiveModelBehavior for ActiveModel {}
