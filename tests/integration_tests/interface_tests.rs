use std::sync::Arc;

use function_name::named;
use futures::{pin_mut, StreamExt};
use photon_indexer::api::method::interface::{
    GetAccountInterfaceRequest, GetMultipleAccountInterfacesRequest,
};
use photon_indexer::common::typedefs::serializable_pubkey::SerializablePubkey;
use photon_indexer::ingester::index_block;
use photon_indexer::ingester::typedefs::block_info::{BlockInfo, BlockMetadata};
use sea_orm::DatabaseConnection;
use serial_test::serial;
use solana_client::nonblocking::rpc_client::RpcClient;

use crate::utils::*;

/// Directory containing interface test transaction data.
/// Generated by forester's test_indexer_interface test.
const INTERFACE_TEST_DATA_DIR: &str = "indexer_interface";

/// Helper to set up indexing methodologies for interface tests.
fn all_indexing_methodologies_for_interface(
    db_conn: Arc<DatabaseConnection>,
    rpc_client: Arc<RpcClient>,
    txns: &[&str],
) -> impl futures::Stream<Item = ()> {
    let txs = txns.iter().map(|x| x.to_string()).collect::<Vec<String>>();
    async_stream::stream! {
        reset_tables(db_conn.as_ref()).await.unwrap();
        populate_test_tree_metadata(db_conn.as_ref()).await;
        index_block(
            db_conn.as_ref(),
            &BlockInfo {
                metadata: BlockMetadata {
                    slot: 0,
                    ..Default::default()
                },
                ..Default::default()
            },
        )
        .await
        .unwrap();

        for tx in &txs {
            index_transaction(INTERFACE_TEST_DATA_DIR, db_conn.clone(), rpc_client.clone(), tx).await;
        }
        yield ();
    }
}

/// Test getAccountInterface resolves compressed token accounts by token owner pubkey.
#[named]
#[rstest]
#[tokio::test]
#[serial]
async fn test_get_account_interface_token_owner(
    #[values(DatabaseBackend::Sqlite, DatabaseBackend::Postgres)] db_backend: DatabaseBackend,
) {
    let name = trim_test_name(function_name!());
    let setup = setup_with_options(
        name.clone(),
        TestSetupOptions {
            network: Network::Localnet,
            db_backend,
        },
    )
    .await;

    // Mint compressed tokens to Bob and Charlie
    let mint_tokens_tx =
        "2YTv5hjSmRAgfwoNHdc4DRDFWW7fqQb57f9s8Rxtu9u6jA2hDxNxEWoiybvn4p7ua2nw3scYeNo6htYCSuBYviFd";

    // Bob's pubkey is the token owner. Interface lookup should return
    // synthetic account data plus compressed token accounts in `cold`.
    let bob_pubkey =
        SerializablePubkey::try_from("DkbH1tracp6nxSQLrHQqJwVE7NaDAAb7eGKzfB9TwBdF").unwrap();

    let txs = [mint_tokens_tx];
    let indexing =
        all_indexing_methodologies_for_interface(setup.db_conn.clone(), setup.client.clone(), &txs);
    pin_mut!(indexing);

    while let Some(_) = indexing.next().await {
        // getAccountInterface must support token-owner lookups.
        let result = setup
            .api
            .get_account_interface(GetAccountInterfaceRequest {
                address: bob_pubkey,
            })
            .await
            .unwrap();

        let value = result.value.clone().expect("expected interface value");
        let cold = value.cold.expect("expected compressed token accounts");
        assert!(
            !cold.is_empty(),
            "expected at least one compressed token account"
        );
    }
}

/// Test getMultipleAccountInterfaces with mixed addresses.
///
/// Tests batch lookup with addresses that don't exist in compressed DB.
#[named]
#[rstest]
#[tokio::test]
#[serial]
async fn test_get_multiple_account_interfaces(
    #[values(DatabaseBackend::Sqlite, DatabaseBackend::Postgres)] db_backend: DatabaseBackend,
) {
    let name = trim_test_name(function_name!());
    let setup = setup_with_options(
        name.clone(),
        TestSetupOptions {
            network: Network::Localnet,
            db_backend,
        },
    )
    .await;

    // Mint compressed tokens to Bob and Charlie
    let mint_tokens_tx =
        "2YTv5hjSmRAgfwoNHdc4DRDFWW7fqQb57f9s8Rxtu9u6jA2hDxNxEWoiybvn4p7ua2nw3scYeNo6htYCSuBYviFd";

    // Token owner pubkeys.
    let bob_pubkey =
        SerializablePubkey::try_from("DkbH1tracp6nxSQLrHQqJwVE7NaDAAb7eGKzfB9TwBdF").unwrap();
    let charlie_pubkey =
        SerializablePubkey::try_from("GDhjk4DmDQ8bFWqrdcLGaJcYBDnq73ExjGyZYrca6nDc").unwrap();
    // Use a random address that definitely doesn't exist on-chain or compressed
    // (default pubkey 11111... is the system program which exists on-chain)
    let nonexistent_address =
        SerializablePubkey::try_from("DeadDeadDeadDeadDeadDeadDeadDeadDeadDeadDead").unwrap();

    let txs = [mint_tokens_tx];
    let indexing =
        all_indexing_methodologies_for_interface(setup.db_conn.clone(), setup.client.clone(), &txs);
    pin_mut!(indexing);

    while let Some(_) = indexing.next().await {
        // Test getMultipleAccountInterfaces
        let result = setup
            .api
            .get_multiple_account_interfaces(GetMultipleAccountInterfacesRequest {
                addresses: vec![bob_pubkey, charlie_pubkey, nonexistent_address],
            })
            .await
            .unwrap();

        // Both owner pubkeys should resolve to token-backed interfaces.
        assert_eq!(result.value.len(), 3);
        assert!(result.value[0]
            .as_ref()
            .and_then(|v| v.cold.as_ref())
            .is_some_and(|cold| !cold.is_empty()));
        assert!(result.value[1]
            .as_ref()
            .and_then(|v| v.cold.as_ref())
            .is_some_and(|cold| !cold.is_empty()));
        assert!(result.value[2].is_none());
    }
}

/// Test batch size validation for getMultipleAccountInterfaces.
#[named]
#[rstest]
#[tokio::test]
#[serial]
async fn test_get_multiple_account_interfaces_validation(
    #[values(DatabaseBackend::Sqlite, DatabaseBackend::Postgres)] db_backend: DatabaseBackend,
) {
    let name = trim_test_name(function_name!());
    let setup = setup_with_options(
        name.clone(),
        TestSetupOptions {
            network: Network::Localnet,
            db_backend,
        },
    )
    .await;

    // Test empty request - should fail
    let empty_result = setup
        .api
        .get_multiple_account_interfaces(GetMultipleAccountInterfacesRequest { addresses: vec![] })
        .await;

    assert!(empty_result.is_err());

    // Test over limit - should fail (MAX_BATCH_SIZE is 100)
    let over_limit: Vec<SerializablePubkey> =
        (0..101).map(|_| SerializablePubkey::default()).collect();

    let over_limit_result = setup
        .api
        .get_multiple_account_interfaces(GetMultipleAccountInterfacesRequest {
            addresses: over_limit,
        })
        .await;

    assert!(over_limit_result.is_err());
}

/*
## Test Data

Test data is generated by forester's test_indexer_interface test:
  cd light-protocol/forester && cargo test -p forester --test test_indexer_interface -- --nocapture

Then exported using:
  cargo xtask export-photon-test-data --test-name indexer_interface

The test creates:
1. SPL Mint (on-chain) - standard mint for token operations
2. Compressed token accounts (via mint_to) - these have NO address field
3. Registered v2 address in batched address tree - for address tree verification
4. Compressible token accounts - on-chain accounts that can be compressed

Transaction files are stored in tests/data/transactions/indexer_interface/

*/
