use std::sync::Arc;

use function_name::named;
use futures::{pin_mut, StreamExt};
use insta::assert_json_snapshot;
use photon_indexer::api::method::interface::{
    GetAccountInterfaceRequest, GetAtaInterfaceRequest, GetMintInterfaceRequest,
    GetMultipleAccountInterfacesRequest, GetTokenAccountInterfaceRequest,
};
use photon_indexer::common::typedefs::serializable_pubkey::SerializablePubkey;
use photon_indexer::ingester::index_block;
use photon_indexer::ingester::typedefs::block_info::{BlockInfo, BlockMetadata};
use sea_orm::DatabaseConnection;
use serial_test::serial;
use solana_client::nonblocking::rpc_client::RpcClient;

use crate::utils::*;

/// Directory containing interface test transaction data.
/// Generated by forester's test_indexer_interface test.
const INTERFACE_TEST_DATA_DIR: &str = "indexer_interface";

/// Helper to set up indexing methodologies for interface tests.
fn all_indexing_methodologies_for_interface(
    db_conn: Arc<DatabaseConnection>,
    rpc_client: Arc<RpcClient>,
    txns: &[&str],
) -> impl futures::Stream<Item = ()> {
    let txs = txns.iter().map(|x| x.to_string()).collect::<Vec<String>>();
    async_stream::stream! {
        reset_tables(db_conn.as_ref()).await.unwrap();
        populate_test_tree_metadata(db_conn.as_ref()).await;
        index_block(
            db_conn.as_ref(),
            &BlockInfo {
                metadata: BlockMetadata {
                    slot: 0,
                    ..Default::default()
                },
                ..Default::default()
            },
        )
        .await
        .unwrap();

        for tx in &txs {
            index_transaction(INTERFACE_TEST_DATA_DIR, db_conn.clone(), rpc_client.clone(), tx).await;
        }
        yield ();
    }
}

/// Test getAccountInterface with nonexistent address.
#[named]
#[rstest]
#[tokio::test]
#[serial]
async fn test_get_account_interface_nonexistent(
    #[values(DatabaseBackend::Sqlite, DatabaseBackend::Postgres)] db_backend: DatabaseBackend,
) {
    let name = trim_test_name(function_name!());
    let setup = setup_with_options(
        name.clone(),
        TestSetupOptions {
            network: Network::Localnet,
            db_backend,
        },
    )
    .await;

    // Mint compressed tokens to Bob and Charlie
    let mint_tokens_tx =
        "2YTv5hjSmRAgfwoNHdc4DRDFWW7fqQb57f9s8Rxtu9u6jA2hDxNxEWoiybvn4p7ua2nw3scYeNo6htYCSuBYviFd";

    // Bob's pubkey - note this is the OWNER of compressed token accounts,
    // not an account ADDRESS. Compressed token accounts don't have addresses.
    let bob_pubkey =
        SerializablePubkey::try_from("DkbH1tracp6nxSQLrHQqJwVE7NaDAAb7eGKzfB9TwBdF").unwrap();

    let txs = [mint_tokens_tx];
    let indexing =
        all_indexing_methodologies_for_interface(setup.db_conn.clone(), setup.client.clone(), &txs);
    pin_mut!(indexing);

    while let Some(_) = indexing.next().await {
        // Test getAccountInterface - should return null since this is an owner pubkey,
        // not an account address
        let result = setup
            .api
            .get_account_interface(GetAccountInterfaceRequest {
                address: bob_pubkey,
            })
            .await
            .unwrap();

        // Expect null - compressed token accounts don't have addresses
        assert!(result.value.is_none());
        assert_json_snapshot!(format!("{}-account-interface", name.clone()), result);
    }
}

/// Test getTokenAccountInterface with owner pubkey.
#[named]
#[rstest]
#[tokio::test]
#[serial]
async fn test_get_token_account_interface_by_owner(
    #[values(DatabaseBackend::Sqlite, DatabaseBackend::Postgres)] db_backend: DatabaseBackend,
) {
    let name = trim_test_name(function_name!());
    let setup = setup_with_options(
        name.clone(),
        TestSetupOptions {
            network: Network::Localnet,
            db_backend,
        },
    )
    .await;

    // Mint compressed tokens to Bob and Charlie
    let mint_tokens_tx =
        "2YTv5hjSmRAgfwoNHdc4DRDFWW7fqQb57f9s8Rxtu9u6jA2hDxNxEWoiybvn4p7ua2nw3scYeNo6htYCSuBYviFd";

    // Bob's owner pubkey (not an account address)
    let bob_pubkey =
        SerializablePubkey::try_from("DkbH1tracp6nxSQLrHQqJwVE7NaDAAb7eGKzfB9TwBdF").unwrap();

    let txs = [mint_tokens_tx];
    let indexing =
        all_indexing_methodologies_for_interface(setup.db_conn.clone(), setup.client.clone(), &txs);
    pin_mut!(indexing);

    while let Some(_) = indexing.next().await {
        // Test getTokenAccountInterface - returns null since compressed token
        // accounts don't have address fields
        let result = setup
            .api
            .get_token_account_interface(GetTokenAccountInterfaceRequest {
                address: bob_pubkey,
            })
            .await
            .unwrap();

        // Expect null - token accounts from mint_to don't have addresses
        assert!(result.value.is_none());
        assert_json_snapshot!(format!("{}-token-account-interface", name.clone()), result);
    }
}

/// Test getMultipleAccountInterfaces with mixed addresses.
///
/// Tests batch lookup with addresses that don't exist in compressed DB.
#[named]
#[rstest]
#[tokio::test]
#[serial]
async fn test_get_multiple_account_interfaces(
    #[values(DatabaseBackend::Sqlite, DatabaseBackend::Postgres)] db_backend: DatabaseBackend,
) {
    let name = trim_test_name(function_name!());
    let setup = setup_with_options(
        name.clone(),
        TestSetupOptions {
            network: Network::Localnet,
            db_backend,
        },
    )
    .await;

    // Mint compressed tokens to Bob and Charlie
    let mint_tokens_tx =
        "2YTv5hjSmRAgfwoNHdc4DRDFWW7fqQb57f9s8Rxtu9u6jA2hDxNxEWoiybvn4p7ua2nw3scYeNo6htYCSuBYviFd";

    // Owner pubkeys (not account addresses)
    let bob_pubkey =
        SerializablePubkey::try_from("DkbH1tracp6nxSQLrHQqJwVE7NaDAAb7eGKzfB9TwBdF").unwrap();
    let charlie_pubkey =
        SerializablePubkey::try_from("GDhjk4DmDQ8bFWqrdcLGaJcYBDnq73ExjGyZYrca6nDc").unwrap();
    // Use a random address that definitely doesn't exist on-chain or compressed
    // (default pubkey 11111... is the system program which exists on-chain)
    let nonexistent_address =
        SerializablePubkey::try_from("DeadDeadDeadDeadDeadDeadDeadDeadDeadDeadDead").unwrap();

    let txs = [mint_tokens_tx];
    let indexing =
        all_indexing_methodologies_for_interface(setup.db_conn.clone(), setup.client.clone(), &txs);
    pin_mut!(indexing);

    while let Some(_) = indexing.next().await {
        // Test getMultipleAccountInterfaces
        let result = setup
            .api
            .get_multiple_account_interfaces(GetMultipleAccountInterfacesRequest {
                addresses: vec![bob_pubkey, charlie_pubkey, nonexistent_address],
            })
            .await
            .unwrap();

        // Verify we get results for each lookup (all null since these are owner pubkeys)
        assert_eq!(result.value.len(), 3);

        assert_json_snapshot!(
            format!("{}-multiple-account-interfaces", name.clone()),
            result
        );
    }
}

/// Test getAtaInterface with owner+mint derivation.
///
/// ATA addresses are derived from owner+mint. Since there's no on-chain ATA
/// and compressed token accounts don't use ATA addresses, this returns null.
#[named]
#[rstest]
#[tokio::test]
#[serial]
async fn test_get_ata_interface(
    #[values(DatabaseBackend::Sqlite, DatabaseBackend::Postgres)] db_backend: DatabaseBackend,
) {
    let name = trim_test_name(function_name!());
    let setup = setup_with_options(
        name.clone(),
        TestSetupOptions {
            network: Network::Localnet,
            db_backend,
        },
    )
    .await;

    // Mint compressed tokens to Bob and Charlie
    let mint_tokens_tx =
        "2YTv5hjSmRAgfwoNHdc4DRDFWW7fqQb57f9s8Rxtu9u6jA2hDxNxEWoiybvn4p7ua2nw3scYeNo6htYCSuBYviFd";

    // Test ATA lookup - derives ATA address from owner+mint
    // Bob is the owner, SPL Mint from the indexer_interface test
    let owner =
        SerializablePubkey::try_from("DkbH1tracp6nxSQLrHQqJwVE7NaDAAb7eGKzfB9TwBdF").unwrap();
    let mint =
        SerializablePubkey::try_from("B8dxn19gmQFB7g1wHsiN2R5jkqEWw14B3CFNQZ9tDwbm").unwrap();

    let txs = [mint_tokens_tx];
    let indexing =
        all_indexing_methodologies_for_interface(setup.db_conn.clone(), setup.client.clone(), &txs);
    pin_mut!(indexing);

    while let Some(_) = indexing.next().await {
        // Test getAtaInterface - returns null since no on-chain or compressed ATA exists
        let result = setup
            .api
            .get_ata_interface(GetAtaInterfaceRequest { owner, mint })
            .await
            .unwrap();

        // Expect null - no ATA exists for this owner+mint
        assert!(result.value.is_none());
        assert_json_snapshot!(format!("{}-ata-interface", name.clone()), result);
    }
}

/// Test getMintInterface with fully compressed mint (cold path only).
///
/// This tests looking up a fully compressed mint by its mint_pda address.
/// The mint was created via CreateMint and then compressed via CompressAndCloseMint.
/// This test is fully reproducible from snapshot data (no live RPC needed).
///
/// Test data flow:
/// 1. CreateMint tx creates compressed mint (initially decompressed on-chain)
/// 2. CompressAndCloseMint tx closes on-chain CMint, full data goes to compressed DB
/// 3. Cold lookup finds full mint data in compressed DB
///
/// To regenerate test data:
/// 1. cd light-protocol/forester && cargo test -p forester --test test_indexer_interface -- --nocapture
/// 2. cargo xtask export-photon-test-data --test-name indexer_interface
/// 3. Copy transactions to photon/tests/data/transactions/indexer_interface/
/// 4. Update transaction signatures and pubkeys below
#[named]
#[rstest]
#[tokio::test]
#[serial]
async fn test_get_mint_interface(
    #[values(DatabaseBackend::Sqlite, DatabaseBackend::Postgres)] db_backend: DatabaseBackend,
) {
    let name = trim_test_name(function_name!());
    let setup = setup_with_options(
        name.clone(),
        TestSetupOptions {
            network: Network::Localnet,
            db_backend,
        },
    )
    .await;

    // Scenario 5: Fully compressed mint (CreateMint + CompressAndCloseMint)
    // These transactions create a mint and then compress it to the compressed DB.
    let create_mint_tx =
        "2Q8KnAuf9TuPThbkEFZp6tfFC9bsGBVEpvoDJzLZAAEDKi2eSZuEdjKrqw9ez2yhxJt5U7S8LYdrUdSq1KKZid4X";
    let compress_mint_tx =
        "2afJTiZyNEMvrKJasbDFqPaTaLWMttjAHnBLgm7CizqzqsiqFp6pXAB9fdrFHq66u6zvv3ddY5xLAzpmREASatnB";

    // Fully compressed mint PDA from Scenario 5
    let compressed_mint =
        SerializablePubkey::try_from("JAisegaP3mQQEqsX7H4qiKoBrPYvr36FW1rpeCKHixUU").unwrap();

    let txs = [create_mint_tx, compress_mint_tx];
    let indexing =
        all_indexing_methodologies_for_interface(setup.db_conn.clone(), setup.client.clone(), &txs);
    pin_mut!(indexing);

    while let Some(_) = indexing.next().await {
        let result = setup
            .api
            .get_mint_interface(GetMintInterfaceRequest {
                address: compressed_mint,
            })
            .await
            .unwrap();

        // With fully compressed mint test data:
        // - resolvedFrom should be "compressed" (from DB, not on-chain)
        // - resolvedSlot should be stable (from DB slot_created)
        // - compressedContext should be present with tree/leaf_index/hash
        assert_json_snapshot!(format!("{}-mint-interface", name.clone()), result);
    }
}

/// Test getMintInterface with non-existent mint.
#[named]
#[rstest]
#[tokio::test]
#[serial]
async fn test_get_mint_interface_nonexistent(
    #[values(DatabaseBackend::Sqlite, DatabaseBackend::Postgres)] db_backend: DatabaseBackend,
) {
    let name = trim_test_name(function_name!());
    let setup = setup_with_options(
        name.clone(),
        TestSetupOptions {
            network: Network::Localnet,
            db_backend,
        },
    )
    .await;

    // Create compressed mint transaction to have slot context
    let create_mint_tx =
        "2Q8KnAuf9TuPThbkEFZp6tfFC9bsGBVEpvoDJzLZAAEDKi2eSZuEdjKrqw9ez2yhxJt5U7S8LYdrUdSq1KKZid4X";

    // Test with a non-existent mint - should return None
    let nonexistent_mint = SerializablePubkey::default();

    let txs = [create_mint_tx];
    let indexing =
        all_indexing_methodologies_for_interface(setup.db_conn.clone(), setup.client.clone(), &txs);
    pin_mut!(indexing);

    while let Some(_) = indexing.next().await {
        let result = setup
            .api
            .get_mint_interface(GetMintInterfaceRequest {
                address: nonexistent_mint,
            })
            .await
            .unwrap();

        // Should return None for non-existent mint
        assert!(result.value.is_none());
        assert_json_snapshot!(format!("{}-mint-interface-none", name.clone()), result);
    }
}

/// Test batch size validation for getMultipleAccountInterfaces.
#[named]
#[rstest]
#[tokio::test]
#[serial]
async fn test_get_multiple_account_interfaces_validation(
    #[values(DatabaseBackend::Sqlite, DatabaseBackend::Postgres)] db_backend: DatabaseBackend,
) {
    let name = trim_test_name(function_name!());
    let setup = setup_with_options(
        name.clone(),
        TestSetupOptions {
            network: Network::Localnet,
            db_backend,
        },
    )
    .await;

    // Test empty request - should fail
    let empty_result = setup
        .api
        .get_multiple_account_interfaces(GetMultipleAccountInterfacesRequest { addresses: vec![] })
        .await;

    assert!(empty_result.is_err());

    // Test over limit - should fail (MAX_BATCH_SIZE is 100)
    let over_limit: Vec<SerializablePubkey> =
        (0..101).map(|_| SerializablePubkey::default()).collect();

    let over_limit_result = setup
        .api
        .get_multiple_account_interfaces(GetMultipleAccountInterfacesRequest {
            addresses: over_limit,
        })
        .await;

    assert!(over_limit_result.is_err());
}

/*
## Test Data

Test data is generated by forester's test_indexer_interface test:
  cd light-protocol/forester && cargo test -p forester --test test_indexer_interface -- --nocapture

Then exported using:
  cargo xtask export-photon-test-data --test-name indexer_interface

The test creates:
1. SPL Mint (on-chain) - standard mint for token operations
2. Compressed token accounts (via mint_to) - these have NO address field
3. Registered v2 address in batched address tree - for address tree verification
4. Decompressed mint (via CreateMint) - CMint on-chain, compressed DB has 32-byte PDA only
5. Fully compressed mint (CreateMint + CompressAndCloseMint) - full data in compressed DB
6. Compressible token accounts - on-chain accounts that can be compressed

Transaction files are stored in tests/data/transactions/indexer_interface/

*/